---
description: >-
  Given an m x n 2D binary grid grid which represents a map of '1's (land) and
  '0's (water), return the number of islands.
---

# 200. Number of Islands

#### example 1

```text
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

#### example 2

```text
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

#### Think

1. use BFS to explore adjacent cell.\(top, bottom ,left, right\).

#### Steps

1. 1
2. 2
3. 3

```java
 public int numIslands(char[][] grid) {
   int nr = grid.length;
   int nc = grid[0].length;
   int numberOfIsland = 0;
   for(int i = 0 ; i < nr ; i++){
     for(int j = 0 ; j < nc ; j++){
       if(grid[i][j] == '1'){
         grid[i][j] = '*' // 走過記為*
         numberOfIsland++;
         Queue<int[]> q = new LinkedList<>();
         q.add(new int[] {i, j});
         while(!q.isEmpty()){
           int[] cur = q.remove();
           int x = cur[0];
           int y = cur[1];
           if(x + 1 < nr && grid[x+1][y] == '1'){
             q.add(new int[]{x+1, y});
             grid[x+1][y] = '*';
           }
           if(x - 1 >= 0 && grid[x-1][y] == '1'){
             q.add(new int[]{x-1, y});
             grid[x-1][y] = '*';
           }
           if(y + 1 < nc && grid[x][y+1] == '1'){
             q.add(new int[]{x, y+1});
             grid[x][y+1] = '*';
           }
           if(y - 1 >= 0 && grid[x][y-1] == '1'){
             q.add(new int[]{x, y-1});
             grid[x][y-1] = '*';
           }
         }
       }
     }
   }
   return numberOfIsland;
 }
```

